//
//A MedicationStatement may be used to record substance abuse or the use of other agents such as tobacco
//or alcohol. This resource does not produce a medication list, but it does produce individual
//medication statements that may be used in the List resource to construct various types of medication lists.
//Note that other medication lists can also be constructed from the other Pharmacy resources
// (e.g., MedicationRequest, MedicationAdministration).
//

package net.pladema.hl7.dataexchange.medications;

import net.pladema.hl7.dataexchange.IMultipleResourceFhir;
import net.pladema.hl7.dataexchange.model.adaptor.FhirDateMapper;
import net.pladema.hl7.dataexchange.model.adaptor.FhirID;
import net.pladema.hl7.supporting.conformance.InteroperabilityCondition;
import net.pladema.hl7.supporting.exchange.database.FhirPersistentStore;
import net.pladema.hl7.supporting.terminology.coding.CodingCode;
import net.pladema.hl7.supporting.terminology.coding.CodingProfile;
import net.pladema.hl7.supporting.terminology.coding.CodingSystem;
import net.pladema.hl7.dataexchange.model.domain.MedicationVo;
import org.apache.commons.lang3.tuple.Pair;
import org.hl7.fhir.r4.model.Bundle;
import org.hl7.fhir.r4.model.Dosage;
import org.hl7.fhir.r4.model.Medication;
import org.hl7.fhir.r4.model.MedicationStatement;
import org.hl7.fhir.r4.model.Quantity;
import org.hl7.fhir.r4.model.Reference;
import org.hl7.fhir.r4.model.Resource;
import org.hl7.fhir.r4.model.ResourceType;
import org.hl7.fhir.r4.model.Timing;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Conditional;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

@Service
@Conditional(InteroperabilityCondition.class)
public class MedicationStatementResource extends IMultipleResourceFhir<MedicationStatement> {

    private final MedicationResource medicationResource;

    @Autowired
    public MedicationStatementResource(FhirPersistentStore store,
                                       MedicationResource medicationResource){
        super(store);
        this.medicationResource= medicationResource;
    }

    @Override
    public ResourceType getResourceType() {
        return ResourceType.MedicationStatement;
    }

    @Override
    public List<MedicationStatement> fetch(String id, Map<ResourceType, Reference> references) {
        return new ArrayList<>();
    }

    public Map<MedicationStatement, Medication> fetchSingle(String id, Map<ResourceType, Reference> references){
        List<MedicationVo> medications = store.findAllMedications(id);

        if(medications.isEmpty())
            return noInformationAvailable(references.get(ResourceType.Patient));

        Map<MedicationStatement, Medication> resources = new LinkedHashMap<>();
        medications.forEach(medication->{
            MedicationStatement resource = new MedicationStatement();
            resource.setId(medication.getStatementId());
            resource.setStatus(MedicationStatement.MedicationStatementStatus.fromCode(medication.getStatus()))
                    .setSubject(references.get(ResourceType.Patient));
            resource.getEffectivePeriod().setStart(FhirDateMapper.toDate(medication.getEffectiveTime()));
            resource.addDosage(buildDosage(medication));

            Medication medicament = medicationResource.fetch(medication);
            resource.setMedication(new Reference(fullDomainUrl(medicament)));

            resource.setMeta(newMeta(CodingProfile.MedicationStatement.URL));
            resources.put(resource, medicament);
        });
        return resources;
    }

    private Map<MedicationStatement, Medication> noInformationAvailable(Reference patientRef) {
        MedicationStatement none = new MedicationStatement()
                .setStatus(MedicationStatement.MedicationStatementStatus.ACTIVE)
                .setSubject(patientRef)
                .setMedication(newCodeableConcept(CodingSystem.NODATA, CodingCode.Medication.KNOWN_ABSENT));
        none.setId(FhirID.autoGenerated());
        none.getEffectivePeriod().addExtension(newExtension(
                CodingProfile.DATA_ABSENT_REASON, CodingCode.ABSENT_REASON)
        );
        Map<MedicationStatement, Medication> resource = new LinkedHashMap<>();
        resource.put(none, null);
        return resource;
    }

    private Dosage buildDosage(MedicationVo medication){
        Dosage dosage = new Dosage()
                .setRoute(newCodeableConcept(CodingSystem.SNOMED, medication.getRoute()))
                .setTiming(new Timing().setRepeat(new Timing.TimingRepeatComponent()
                        .setCount(1)
                        .setPeriodUnit(Timing.UnitsOfTime.fromCode(medication.getUnitTime()))
                ));
        dosage.addDoseAndRate()
                .setType(newCodeableConcept(CodingSystem.MedicationStatement.DOSE, CodingCode.Medication.DOSE))
                .setDose(newQuantity(CodingSystem.SNOMED,
                        medication.getDoseQuantityCode(),
                        medication.getDoseQuantityUnit(),
                        medication.getDoseQuantityValue()));
        return dosage;
    }

    @Override
    public List<Bundle.BundleEntryComponent> fetchEntries(String id, Map<ResourceType, Reference> references) {
        List<Bundle.BundleEntryComponent> entries = new ArrayList<>();
        fetchSingle(id, references).forEach((statement, medication) -> {
            entries.add(fetchEntry(statement));
            if(medication != null)
                entries.add(fetchEntry(medication));
        });
        return entries;
    }

    public static MedicationVo encode(Resource baseResource, Resource baseResource2) {
        MedicationVo data = new MedicationVo();
        MedicationStatement resource = (MedicationStatement) baseResource;

        //Medication-statement
        data.setStatementId(resource.getId());
        if(resource.hasDosage()) {
            Dosage dosage = resource.getDosage().get(0);
            if (dosage.hasRoute()) {
                Pair<String,String> route = decodeCoding(dosage.getRoute());
                data.setRouteCode(route.getKey());
                data.setRouteTerm(route.getValue());
            }
            if (dosage.hasTiming()) {
                Timing.TimingRepeatComponent repeat = dosage.getTiming().getRepeat();
                data.setUnitTime(repeat.getPeriodUnit().getDisplay());
            }
            if (dosage.hasDoseAndRate()) {
                Dosage.DosageDoseAndRateComponent doseAndRate = dosage.getDoseAndRate().get(0);
                if(doseAndRate.hasDoseQuantity()) {
                    Quantity quantity = doseAndRate.getDoseQuantity();
                    data.setDoseQuantityCode(quantity.getCode());
                    data.setDoseQuantityUnit(quantity.getUnit());
                    data.setDoseQuantityValue(quantity.getValue());
                }
            }
        }
        if(resource.hasStatus())
            data.setStatus(resource.getStatus().getDisplay());
        if(resource.hasEffective())
            data.setEffectiveTime(FhirDateMapper.toLocalDate(resource.getEffectiveDateTimeType().getValue()));

        //Medication data
        if(resource.hasMedicationReference()) {
            Medication medication = (Medication) baseResource2;
            MedicationResource.encode(data, medication);
        }
        else if(resource.hasMedicationCodeableConcept()){
            Pair<String, String> coding = decodeCoding(resource.getMedicationCodeableConcept());
            data.setSctidCode(coding.getKey());
            data.setSctidTerm(coding.getValue());
        }
        return data;
    }
}
